import { mkdir, readFile, writeFile } from "node:fs/promises";
import path from "node:path";
import { fileURLToPath } from "node:url";

type RegistrySkill = {
  id: string;
  title: string;
  description?: string;
  repo: string;
  targetPackages?: string[];
  installs?: number;
};

const __dirname = path.dirname(fileURLToPath(import.meta.url));
const rootDir = path.resolve(__dirname, "..");
const registryPath = path.join(rootDir, ".upskill", "skills-registry.json");
const mappingsPath = path.join(rootDir, ".upskill", "package-mappings.json");
const outDir = path.join(rootDir, "scripts");
const outPath = path.join(outDir, "seed-turso.sql");

function escapeSql(value: string): string {
  return value.replace(/'/g, "''");
}

function normalizePackages(values: unknown): string[] {
  if (!Array.isArray(values)) return [];
  return values
    .filter((value) => typeof value === "string")
    .map((value) => value.trim())
    .filter(Boolean);
}

const registryRaw = await readFile(registryPath, "utf-8");
const registryParsed = JSON.parse(registryRaw);
const skills: RegistrySkill[] = Array.isArray(registryParsed)
  ? registryParsed
  : registryParsed.skills;

if (!Array.isArray(skills)) {
  throw new Error("Invalid skills registry format.");
}

const mappingsRaw = await readFile(mappingsPath, "utf-8");
const mappingsParsed = JSON.parse(mappingsRaw) as Record<string, string[]>;

const packageSet = new Set<string>();
const skillPackages = new Map<string, string[]>();

for (const skill of skills) {
  if (!skill?.id) continue;
  const targetPackages = normalizePackages(skill.targetPackages);
  const mappedPackages = normalizePackages(mappingsParsed?.[skill.id]);
  const combined = Array.from(
    new Set([...targetPackages, ...mappedPackages]),
  );
  skillPackages.set(skill.id, combined);
  for (const pkg of combined) packageSet.add(pkg);
}

const lines: string[] = [];
lines.push("-- Generated by scripts/seed-turso.ts");
lines.push("PRAGMA foreign_keys = ON;");
lines.push("BEGIN;");
lines.push("DROP TABLE IF EXISTS package_skills_asscn;");
lines.push("DROP TABLE IF EXISTS package_skill_asscn;");
lines.push("DROP TABLE IF EXISTS skills;");
lines.push("DROP TABLE IF EXISTS packages;");
lines.push(
  "CREATE TABLE IF NOT EXISTS skills (" +
    "id INTEGER PRIMARY KEY AUTOINCREMENT," +
    "name TEXT NOT NULL UNIQUE," +
    "title TEXT NOT NULL," +
    "description TEXT," +
    "repo TEXT NOT NULL," +
    "installs INTEGER NOT NULL DEFAULT 0," +
    "created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)," +
    "updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)" +
    ");",
);
lines.push(
  "CREATE TABLE IF NOT EXISTS packages (" +
    "id INTEGER PRIMARY KEY AUTOINCREMENT," +
    "name TEXT NOT NULL UNIQUE," +
    "created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)," +
    "updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)" +
    ");",
);
lines.push(
  "CREATE TABLE IF NOT EXISTS package_skill_asscn (" +
    "package_id INTEGER NOT NULL," +
    "skill_id INTEGER NOT NULL," +
    "created_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)," +
    "updated_at TEXT NOT NULL DEFAULT (CURRENT_TIMESTAMP)," +
    "PRIMARY KEY (package_id, skill_id)," +
    "FOREIGN KEY (package_id) REFERENCES packages(id) ON DELETE CASCADE," +
    "FOREIGN KEY (skill_id) REFERENCES skills(id) ON DELETE CASCADE" +
    ");",
);
lines.push(
  "CREATE INDEX IF NOT EXISTS idx_package_skill_asscn_package " +
    "ON package_skill_asscn(package_id);",
);
lines.push(
  "CREATE INDEX IF NOT EXISTS idx_package_skill_asscn_skill " +
    "ON package_skill_asscn(skill_id);",
);

const sortedPackages = Array.from(packageSet).sort((a, b) =>
  a.localeCompare(b),
);
for (const pkg of sortedPackages) {
  lines.push(
    `INSERT OR IGNORE INTO packages (name) VALUES ('${escapeSql(pkg)}');`,
  );
}

for (const skill of skills) {
  if (!skill?.id || !skill?.title || !skill?.repo) continue;
  const description =
    typeof skill.description === "string" && skill.description.trim().length > 0
      ? `'${escapeSql(skill.description)}'`
      : "NULL";
  const installs = Number.isFinite(skill.installs ?? NaN)
    ? Math.trunc(skill.installs ?? 0)
    : 0;

  lines.push(
    "INSERT OR REPLACE INTO skills " +
      "(name, title, description, repo, installs) VALUES (" +
      `'${escapeSql(skill.id)}', ` +
      `'${escapeSql(skill.title)}', ` +
      `${description}, ` +
      `'${escapeSql(skill.repo)}', ` +
      `${installs}` +
      ");",
  );

  const packagesForSkill = skillPackages.get(skill.id) ?? [];
  for (const pkg of packagesForSkill) {
    lines.push(
      "INSERT OR IGNORE INTO package_skill_asscn " +
        "(package_id, skill_id) VALUES (" +
        `(SELECT id FROM packages WHERE name = '${escapeSql(pkg)}'), ` +
        `(SELECT id FROM skills WHERE name = '${escapeSql(skill.id)}')` +
        ");",
    );
  }
}

lines.push("COMMIT;");

await mkdir(outDir, { recursive: true });
await writeFile(outPath, `${lines.join("\n")}\n`, "utf-8");

console.log(`Seed SQL generated at ${outPath}`);
